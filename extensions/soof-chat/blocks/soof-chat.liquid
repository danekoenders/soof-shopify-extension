<soof-chat local-language="{{ localization.language.iso_code }}"></soof-chat>

<script defer>
  class ChatBot extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this.isMobile = this.mobileCheck();
      this.chatWrapper = null;
      this.isOpen = false;
      this.scriptsLoaded = false;
      this.messages = [];
      this.sendDisabled = true;
      this.hideChatInput = true;
      this.serveData = null;
      this.chatSession = this.getChatSession();
      this.cache = this.getCache();
      this.soofProxyURI = 'soof-proxy--dev';
      this.localLanguage = this.getAttribute('local-language') || false;
      this.assistantId = null;
      this.threadId = null;
      this.langGraphUrl = null;

      // Track current LangGraph run state
      this.currentRun = {
        steps: {}, // nodeName -> {status: 'running'|'done', msgIndex}
        respondMessageIndex: null,
      };

      this.chatIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon"><path d="M2 15V5c0-1.1.9-2 2-2h16a2 2 0 0 1 2 2v15a1 1 0 0 1-1.7.7L16.58 17H4a2 2 0 0 1-2-2z"/><path  d="M6 7h12a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2zm0 4h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2z"/></svg>`;
      this.closeIcon = `<svg xmlns="http://www.w3.org/2000/svg" style="display: block; margin: auto; transform: scale(1.5, 1.5);" viewBox="0 0 24 24" class="icon"><path transform="translate(0.5,0)" fill-rule="evenodd" d="M15.78 14.36a1 1 0 0 1-1.42 1.42l-2.82-2.83-2.83 2.83a1 1 0 1 1-1.42-1.42l2.83-2.82L7.3 8.7a1 1 0 0 1 1.42-1.42l2.83 2.83 2.82-2.83a1 1 0 0 1 1.42 1.42l-2.83 2.83 2.83 2.82z"/></svg>`;
      this.loaderIcon = `<div class="loader"></div>`;
      this.typingIndicator = `<div class="typing-indicator"><span></span><span></span><span></span></div>`;
      this.sendButtonIcon = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 500 500"><g><g><polygon points="0,497.25 535.5,267.75 0,38.25 0,216.75 382.5,267.75 0,318.75"></polygon></g></g></svg>`;
      this.carouselArrowIcon = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40" width="40" height="40" focusable="false"><path d="m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z"></path></svg>`;
    }

    get styles() {
      const styleGuide = this.serveData.chatbot.theme;

      return `
          :host {
            display: block;
            position: fixed;
            bottom: 25px;
            ${this.serveData.chatbot.options.alignment}: 25px;
            z-index: 141;
          }

          ${this.isMobile && this.isOpen ? `
              .chat-wrapper {
                  position: fixed;
                  width: 100vw;
                  height: 100vh;
                  height: -webkit-fill-available;
                  bottom: 0;
                  right: 0;
              }

              .toggle-chat-button {
                  position: absolute;
                  right: 1em;
                  top: 1em;
                  z-index: 142;
                  background: none;
                  width: 50px;
                  height: 50px;
              }
            ` : ''
          }

          .chat-window {
              display: ${this.isOpen ? 'flex' : 'none'};
              width: ${this.isMobile ? '100%' : '450px'};
              height: ${this.isMobile ? '100%' : '750px'};;
              position: absolute;
              bottom: ${this.isMobile ? '0' : '80px'};
              ${this.serveData.chatbot.options.alignment}: 0;
              background-color: ${styleGuide.background};
              border-radius: ${this.isMobile ? '0' : '15px'};
              box-shadow: 0 2px 10px rgba(0,0,0,0.5);
              flex-direction: column;
              font-size 16px;
              line-height: 20px;
          }
      
          .icon {
          fill: white;
          }

          .loader {
              border: 4px solid ${styleGuide.tertiaryAccent};
              border-top: 4px solid ${styleGuide.primaryAccent};
              border-radius: 50%;
              width: 14px;
              height: 14px;
              animation: spin 1s linear infinite;
          }

          @keyframes spin {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
          }

          svg {
              fill: ${styleGuide.secondaryText};
          }

          input {
              border: 1px solid ${styleGuide.secondaryBorder};
              border-radius: 10px;
              padding: 12px 14px;
              font-size: ${this.isMobile ? '16px' : '0.9em'};
              width: 180px;
              background-color: ${styleGuide.background};
          }

          input:focus {
              outline: none;
              border-color: ${styleGuide.primaryAccent};
          }

          input:disabled {
              background-color: ${styleGuide.disabledBackground};
              cursor: not-allowed;
          }

          ::placeholder {
              color: ${styleGuide.primaryText};
          }

          ::-ms-input-placeholder {
              color: ${styleGuide.primaryText};
          }
      
          button {
            width: 60px;
            height: 60px;
            padding: 10px;
            background-color: ${styleGuide.primaryBackground};
            border-radius: 50%;
            color: ${styleGuide.secondaryText};
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
          }
      
          button:hover {
            filter: brightness(90%);
          }

          .button:disabled {
              background-color: ${styleGuide.disabledBackground};
              cursor: not-allowed;
          }

          .chat-header {
              background: linear-gradient(130deg, ${styleGuide.primaryBackground} 50%, ${styleGuide.secondaryBackground} 100%);
              min-height: 140px;
              color: white;
              border-top-left-radius: ${this.isMobile ? '0' : '15px'};
              border-top-right-radius: ${this.isMobile ? '0' : '15px'};
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              line-height: 1.2;
              font-size: 1.2em;
          }

          .chat-header h4 {
              font-size: 1.2em;
              margin: 0;
          }

          .chat-header span {
              font-size: 0.9em;
          }

          .chat-header-buttons {
              display: flex;
              gap: 10px;
              margin-top: 10px;
          }

          .chat-header-buttons button {
              width: fit-content;
              height: fit-content;
              padding: 4px 10px;
              border-radius: 5px;
              border: 1px solid ${styleGuide.tertiaryAccent};
              background: transparent;
              color: ${styleGuide.tertiaryAccent};
              font-size: 0.8em;
              cursor: pointer;
          }
      
          .chat-log {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
              gap: 10px;
              overflow-y: auto;
              padding: 14px;
          }
      
          .chat-log .message-wrapper {
              display: flex;
              flex-direction: column;
              gap: 6px;
              width: 100%;
          }

          .chat-log .message-wrapper .options {
              display: flex;
              flex-direction: row;
              flex-wrap: wrap;
              justify-content: flex-start;
              gap: 5px;
          }

          .chat-log .message-wrapper .options button {
              width: fit-content;
              height: 24px;
              padding: 5px 10px;
              border-radius: 4px;
              border: 0;
              background: ${styleGuide.optionsBackground};
              color: ${styleGuide.secondaryText};
              font-size: 0.8em;
              cursor: pointer;
          }

          .chat-log .message {
              padding: 12px;
              width: fit-content;
          }

          .chat-log .order-tracking .message {
              display: flex;
              justify-content: space-between;
              align-items: center;
              gap: 15px;
          }

          .chat-log .order-tracking .message h4 {
              margin: 0;
          }

          .chat-log .order-tracking .message p {
              text-transform: capitalize;
              text-wrap-style: pretty;
          }

          .chat-log .order-tracking .message a {
              display: flex;
              align-items: center;
              justify-content: center;
          }

          .chat-log .message p {
              margin: 0;
              font-size: 1em;
              line-height: 1.4;
              color: ${styleGuide.primaryText};
          }

          .chat-log .message h1,
          .chat-log .message h2,
          .chat-log .message h3,
          .chat-log .message h4,
          .chat-log .message h5,
          .chat-log .message h6 {
              margin: 0;
              font-weight: bold;
              color: ${styleGuide.primaryText};
          }

          .chat-log .message h4,
          .chat-log .message h5,
          .chat-log .message h6 {
              margin-top: 10px;
          }

          .chat-log .message ul, ol {
              color: ${styleGuide.primaryText};
              margin: 0;
              padding: 12px 0px 6px 20px;
          }

          .chat-log .message li {
              margin-bottom: 6px;
              font-size: 0.97em;
          }

          .chat-log .message a {
              color: ${styleGuide.accentText};
              text-decoration: none;
          }

          .chat-log .message a:hover {
              text-decoration: underline;
          }

          .chat-log .user {
              align-items: flex-end;
          }

          .chat-log .user .message {
              border-radius: 20px 1px 20px 20px;
              border: 1px solid ${styleGuide.secondaryBorder};
              background: ${styleGuide.userChatBackground}12;
              max-width: 90%;
          }

          .chat-log .assistant {
              align-items: flex-start;
          }

          .chat-log .assistant .message {
              border-radius: 1px 20px 20px 20px;
              border: 1px solid ${styleGuide.primaryBorder};
              background: ${styleGuide.botChatBackground};
              max-width: 90%;
          }

          .chat-log .assistant-loading .message {
              color: black;
              border-radius: 1px 20px 20px 20px;
              border: 1px solid ${styleGuide.primaryBorder};
              background: ${styleGuide.botChatBackground};
          }

          .chat-log .assistant-loading .typing-indicator {
              display: flex;
              align-items: center;
              height: 12px;
              margin-left: 6px;
          }

          .typing-indicator {
              display: inline-flex;
              align-items: center;
              gap: 2px;
              color: ${styleGuide.accentText};
              font-size: 1.2em;
              animation: pulse 1.5s infinite;
          }

          @keyframes pulse {
              0%, 100% { opacity: 0.4; }
              50% { opacity: 1; }
          }

          .typing-indicator span {
              display: inline-block;
              width: 8px;
              height: 8px;
              margin: 0 2px;
              background: ${styleGuide.accentText};
              border-radius: 50%;
              animation: blink 1.4s infinite both;
          }

          .typing-indicator span:nth-child(1) {
              animation-delay: 0.2s;
          }

          .typing-indicator span:nth-child(2) {
              animation-delay: 0.4s;
          }

          .typing-indicator span:nth-child(3) {
              animation-delay: 0.6s;
          }

          @keyframes blink {
              0% {
                  opacity: 0.2;
              }
              20% {
                  opacity: 1;
              }
              100% {
                  opacity: 0.2;
              }
          }

          .chat-log .assistant-error .message {
              color: ${styleGuide.primaryText};
              border-radius: 1px 20px 20px 20px;
              border: 1px solid ${styleGuide.errorAccentColor};
              background: ${styleGuide.botChatBackground};
          }

          .chat-log .email-input {
              display: flex;
              align-items: center;
              gap: 5px;
          }

          .chat-log .email-input button {
              width: 42px;
              height: 42px;
              padding: 10px;
          }

          .carousel {
              width: 100%;
          }
          
          .carousel-item {
              background-color: ${styleGuide.botChatBackground};
              color: ${styleGuide.primaryText};
              border: 1px solid ${styleGuide.primaryBorder};
              border-radius: 1px 20px 20px 20px;
          }

          .carousel-item-cover {
              background-position: center;
              background-size: cover;
              background-repeat: no-repeat;
              width: 100%;
              height: 200px;
              object-fit: cover;
              border-radius: 0 20px 0 0;
          }

          .carousel-item-details {
              padding: 20px;
              display: flex;
              flex-direction: column;
          }

          .carousel-utils {
              display: flex;
              align-items: center;
              gap: 10px;
              width: 100%;
              padding: 10px;
          }

          .carousel-progress {
              width: 30%;
              background: ${styleGuide.dullGrayAccentColor};
          }
          
          .carousel-progress-bar {
              background: ${styleGuide.primaryAccent};
              height: 2px;
              transition: width 400ms ease;
          }

          .carousel .splide__arrows {
              display: flex;
              gap: 6px;
              width: fit-content;
              position: relative;
          }

          .carousel .splide__arrow {
              position: relative;
              transform: none;
              background: ${styleGuide.secondaryBackground};
          }

          .carousel .splide__arrow svg {
              fill: ${styleGuide.secondaryText};
          }

          .carousel .splide__arrow--prev {
              left: 0;
          }

          .carousel .splide__arrow--next {
              right: 0;
          }

          .chat-input {
              display: flex;
              gap: 5px;
              padding: 10px 14px;
              border-bottom-left-radius: ${this.isMobile ? '0' : '15px'};
              border-bottom-right-radius: ${this.isMobile ? '0' : '15px'};
          }
      
          .chat-input input {
              color: ${styleGuide.primaryText};
              flex-grow: 1;
              padding: 5px 10px;
              border: none;
              border-radius: 12px;
              box-shadow: ${styleGuide.boxShadow};
              ${this.isMobile ? '16px' : '1em'};
              background-color: ${styleGuide.background};
              border: 1px solid ${styleGuide.background};
          }

          .chat-input input:focus {
              outline: none;
              border: 1px solid ${styleGuide.primaryAccent};
          }
      
          .chat-input button {
              width: 55px;
              height: 55px;
              padding: 5px 15px;
              color: ${styleGuide.secondaryText};
              background-color: ${styleGuide.primaryBackground};
              border: none;
              border-radius: 15px;
              cursor: pointer;
              transition: background-color 0.3s;
          }

          .chat-input button:disabled {
              background-color: ${styleGuide.disabledBackground};
              cursor: not-allowed;
          }

          .processing-status {
              background: ${styleGuide.primaryAccent}20;
              border: 1px solid ${styleGuide.primaryAccent};
              border-radius: 12px;
              padding: 8px 12px;
              margin: 5px 0;
              font-size: 0.85em;
              color: ${styleGuide.primaryAccent};
              text-align: center;
              animation: statusPulse 2s infinite;
              display: none;
          }

          @keyframes statusPulse {
              0%, 100% { background: ${styleGuide.primaryAccent}20; }
              50% { background: ${styleGuide.primaryAccent}30; }
          }
      `;
    }

    get startChatMessage() {
      return `{{ 'chat.start.first' | t }}` + ` ${this.serveData.shop?.name || '{{ 'chat.start.notSpecified' | t }}'}` + `{{ 'chat.start.second' | t }}`;
    }

    get welcomeMessage() {
      return `{{ 'chat.welcome.message.first' | t }}` + `${this.serveData.chatbot.name || '{{ 'chat.welcome.message.notSpecified' | t }}'}` + `{{ 'chat.welcome.message.second' | t }}`;
    }

    openChatWindow() {
      if (!this.isOpen) {
        this.isOpen = true;
        this.toggleBodyScroll(this.isOpen && this.isMobile);
        this.renderBase();
      }
    }
  
    closeChatWindow() {
      if (this.isOpen) {
        this.isOpen = false;
        this.toggleBodyScroll(this.isOpen && this.isMobile);
        this.renderBase();
      }
    }

    async connectedCallback() {
      const chatWrapper = document.createElement('div');
      chatWrapper.className = 'chat-wrapper';
      this.chatWrapper = this.shadowRoot.appendChild(chatWrapper);
      try {
        if (this.localLanguage) {
          window.openSoofChat = this.openChatWindow.bind(this);
          window.closeSoofChat = this.closeChatWindow.bind(this);

          if (this.cache.data.chatbot && this.cache.data.shop) {
            this.serveData = this.cache.data;
          } else {
            await this.fetchServeData();
            this.setCache();
          }

          if (this.chatSession.active) {
            if (this.chatSession.transcript) {
              this.messages = this.chatSession.transcript;
            }
            // Restore assistantId and threadId from session
            if (this.chatSession.assistantId) {
              this.assistantId = this.chatSession.assistantId;
            }
            if (this.chatSession.threadId) {
              this.threadId = this.chatSession.threadId;
            }
            if (this.chatSession.langGraphUrl) {
              this.langGraphUrl = this.chatSession.langGraphUrl;
            }
            this.chatSession.active = true;
            this.sendDisabled = false;
          } else {
            this.messages.push({
              role: 'assistant',
              type: 'normal',
              content: this.startChatMessage,
            });

            this.messages.push({
              role: 'assistant',
              type: 'email-input',
            });
          }

          this.renderBase();
        } else {
          console.error('Local language not set.');
        }
      } catch (error) {
        console.error('Error setting up chatbot:', error);
      }
    }

    disconnectedCallback() {
      if (this.loadingTimeout) {
        clearTimeout(this.loadingTimeout);
      }
      this.toggleBodyScroll(false);
    }

    mobileCheck() {
      let check = false;
      (function (a) {
        if (
          /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
            a
          ) ||
          /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
            a.substr(0, 4)
          )
        )
          check = true;
      })(navigator.userAgent || navigator.vendor || window.opera);
      return check;
    }

    getChatSession() {
      const itemString = localStorage.getItem('soof-chat-session');
      const defaultObject = {
        active: false,
        expiresAt: null,
        userEmail: null,
        sessionToken: null,
        transcript: null,
        assistantId: null,
        threadId: null,
        langGraphUrl: null,
      };

      if (itemString) {
        const item = JSON.parse(itemString);
        const now = new Date();
        const expiresAt = new Date(item.expiresAt);

        if (expiresAt < now) {
          localStorage.removeItem('soof-chat-session');
          return defaultObject;
        } else {
          return item;
        }
      } else {
        return defaultObject;
      }
    }

    setChatSession() {
      localStorage.setItem(
        'soof-chat-session',
        JSON.stringify({
          active: true,
          expiresAt: this.chatSession.expiresAt,
          userEmail: this.chatSession.userEmail,
          transcript: this.messages,
          sessionToken: this.chatSession.sessionToken,
          assistantId: this.assistantId,
          threadId: this.threadId,
          langGraphUrl: this.langGraphUrl,
        })
      );
    }

    getCache() {
      const itemString = sessionStorage.getItem('soof-chat-cache');
      const defaultObject = {
        data: {
          chatbot: null,
          shop: null,
        },
        expiresAt: null,
      };
    
      if (itemString) {
        const item = JSON.parse(itemString);
        const now = new Date();
        const expiresAt = new Date(item.expiresAt);
    
        if (expiresAt < now) {
          sessionStorage.removeItem('soof-chat-cache');
          return defaultObject;
        } else {
          return item;
        }
      } else {
        return defaultObject;
      }
    }

    setCache() {
      const now = new Date();
      this.cache.data = this.serveData;
    
      const item = {
        data: this.cache.data,
        expiresAt: new Date(now.getTime() + 1 * 24 * 60 * 60 * 1000).toISOString(),
      };
      sessionStorage.setItem('soof-chat-cache', JSON.stringify(item));
    }    

    async fetchServeData() {
      try {
        const response = await fetch(`${window.location.origin}/apps/${this.soofProxyURI}/chatbot/serve`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) throw new Error('Failed to fetch');
        this.serveData = await response.json();
      } catch (error) {
        console.error('Fetch error:', error);
      }
    }

    async startChat({ email }) {
      try {
        const emailSendButton = this.shadowRoot.getElementById('email-send-button');
        emailSendButton.innerHTML = this.loaderIcon;

        const response = await fetch(`${window.location.origin}/apps/${this.soofProxyURI}/chat/session/chatToken`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            email: email,
            localLanguage: this.localLanguage,
          }),
        });

        if (!response.ok) {
          emailSendButton.innerHTML = this.sendButtonIcon;
          throw new Error('Invalid email address. Please try again.');
        }

        const data = await response.json();
        if (data.token) {
          this.chatSession.sessionToken = data.token;
          this.chatSession.expiresAt = data.expiresAt;
          this.assistantId = data.assistant;
          this.threadId = data.thread;
          this.langGraphUrl = data.langGraphUrl;

          this.shadowRoot.appendChild(document.createElement('script')).src =
            'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
          this.shadowRoot.appendChild(document.createElement('script')).src =
            'https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js';

          this.messages = [];
          this.messages.push({
            role: 'assistant',
            type: 'normal',
            content: this.welcomeMessage,
            options: [
              { label: '{{ 'chat.welcome.options.1.label' | t }}', value: '{{ 'chat.welcome.options.1.value' | t }}' },
              { label: '{{ 'chat.welcome.options.2.label' | t }}', value: '{{ 'chat.welcome.options.2.value' | t }}' },
              { label: '{{ 'chat.welcome.options.3.label' | t }}', value: '{{ 'chat.welcome.options.3.value' | t }}' },
            ],
          });

          this.sendDisabled = false;
          this.hideChatInput = false;
          this.chatSession.active = true;
          this.chatSession.userEmail = email;

          this.updateSendState();
          this.setChatSession();
        }
      } catch (error) {
        console.error('There was a problem submitting the email:', error);
        this.messages.push({
          role: 'assistant-error',
          type: 'normal',
          content: '{{ 'email.error' | t }}',
        });
      }

      this.renderMessages();
    }

    renderBase() {
      this.chatWrapper.innerHTML = `
              <style>${this.styles}</style>
              <button class="toggle-chat-button">${this.isOpen ? this.closeIcon : this.chatIcon}</button>
              ${
                this.isOpen
                  ? `
                  <div class="chat-window">
                      <div class="chat-header">
                          <h4>${this.serveData.shop?.name || '{{ 'chat.base.header.title' | t }}'}</h4>
                          <span>{{ 'chat.base.header.subtitle.first' | t }} ${this.serveData.chatbot?.customName || '{{ 'chat.base.header.subtitle.notSpecified' | t }}'}</span>
                          <div class="chat-header-buttons">
                              <button id="restart-chat-button">{{ 'chat.base.header.newChat' | t }}</button>
                              <!-- // TODO: Add FAQ button
                              <button id="faq-button">{{ 'chat.base.header.faq' | t }}</button>
                              -->
                          </div>
                      </div>
                      <div class="chat-log"></div>
                      <div class="chat-input">
                          <input id="chat-input-field" name="question" type="text" placeholder="{{ 'chat.base.input.placeholder' | t }}">
                          <button id="send-button" ${this.sendDisabled ? 'disabled' : ''}>${
                      this.sendButtonIcon
                    }</button>
                      </div>
                  </div>
              `
                  : ''
              }
          `;
      if (this.isOpen) {
        if (this.scriptsLoaded) {
          this.renderMessages();
        } else {
          this.loadScripts();
        }
        this.updateSendState();
      }
      this.addBaseEventListeners();
    }

    renderMessages() {
      const chatLog = this.shadowRoot.querySelector('.chat-log');
      if (!chatLog) {
        console.error('Chat log element not found in the DOM.');
        return;
      }

      chatLog.innerHTML = this.messages
        .map((msg, msgIndex) => {
          if (msg.type === 'email-input') {
            return `
                  <div class="message-wrapper ${msg.role}">
                      <div class="message">
                          <div class="email-input">
                              <input type="email" name="email" ${
                                msg.email && `value="${msg.email}" `
                              }autocomplete="email" placeholder="{{ 'chat.messages.email.placeholder' | t }}">
                              <button id="email-send-button">${this.sendButtonIcon}</button>
                          </div>
                      </div>
                  </div>
              `;
          } else if (msg.type === 'normal') {
            // Handle streaming messages with no content yet
            let messageContent = msg.content || '';
            if (msg.isStreaming && !messageContent) {
              messageContent = '<span class="typing-indicator">‚óè‚óè‚óè</span>';
            }
            
            let messageHtml = '';
            if (messageContent) {
              if (typeof marked !== 'undefined' && typeof DOMPurify !== 'undefined') {
                messageHtml = marked.parse(DOMPurify.sanitize(messageContent));
              } else {
                // Fallback: escape HTML entities and preserve line breaks
                const escapeHtml = (unsafe) => unsafe
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/\"/g, "&quot;")
                  .replace(/'/g, "&#039;");
                messageHtml = `<p>${escapeHtml(messageContent).replace(/\n/g, '<br>')}</p>`;
              }
            }
            return `
                  <div class="message-wrapper ${msg.role}">
                      <div class="message">${messageHtml}</div>
                      ${
                        msg.options
                          ? `
                          <div class="options">
                              ${msg.options
                                .map(
                                  (option, optionIndex) => `
                                  <button id="option-button-${msgIndex}-${optionIndex}">${option.label}</button>
                              `
                                )
                                .join('')}
                          </div>
                      `
                          : ''
                      }
                  </div>
              `;
          } else if (msg.type === 'orderTracking') {
            return `
                  <div class="message-wrapper ${msg.role}">
                      <div class="message"><p>{{ 'chat.messages.orderTracking.message' | t }}</p></div>
                  </div>
                  
                  <div class="message-wrapper order-tracking ${msg.role}">
                      <div class="message">
                        <div>
                          <h4>Order #${msg.order.orderNumber}</h4>
                          <p>Status: ${msg.order.financialStatus}</p>
                        </div>
                        <a href="${msg.order.orderStatusUrl}" target="_blank">
                          <img src="{{ 'eye.svg' | asset_url }}">
                        </a>
                      </div>
                      ${
                        msg.options
                          ? `
                          <div class="options">
                              ${msg.options
                                .map(
                                  (option, optionIndex) => `
                                  <button id="option-button-${msgIndex}-${optionIndex}">${option.label}</button>
                              `
                                )
                                .join('')}
                          </div>
                      `
                          : ''
                      }
                  </div>
              `;
          } else if (msg.type === 'productRecommendation') {
            const currentHost = window.location.origin;
            const pathnameParts = window.location.pathname.split('/').filter(Boolean);
            const languagePattern = /^[a-z]{2}(-[A-Z]{2})?$/;
            const language = pathnameParts[0] && languagePattern.test(pathnameParts[0]) ? pathnameParts[0] : '';

            return `
                  <div class="message-wrapper ${msg.role}">
                      <div class="message"><p>{{ 'chat.messages.productRecommendation.message' | t }}</p></div>
                  </div>

                  <div class="message-wrapper ${msg.role}">
                      <div class="splide carousel">
                          <div class="splide__track">
                              <ul class="splide__list">
                                  ${msg.products
                                    .map(
                                      (product) => `
                                      <li class="splide__slide">
                                          <div class="carousel-item">
                                              <div class="carousel-item-cover" style="background-image: url(${
                                                product.images[0]?.node.source || ''
                                              })"></div>
                                              <div class="carousel-item-details">
                                                <a href="${currentHost}/${language ? `${language}/` : ''}products/${product.handle}" target="_blank">
                                                  <span>${product.title}</span>
                                                </a>
                                                <span>‚Ç¨${product.variants[0].node.price || ''}</span>
                                              </div>
                                          </div>
                                      </li>
                                  `
                                    )
                                    .join('')}
                              </ul>
                          </div>

                          <div class="carousel-utils">
                              <div class="carousel-progress">
                                  <div class="carousel-progress-bar"></div>
                              </div>
                              <div class="splide__arrows">
                                  <button class="splide__arrow splide__arrow--prev">
                                      ${this.carouselArrowIcon}
                                  </button>
                                  <button class="splide__arrow splide__arrow--next">
                                      ${this.carouselArrowIcon}
                                  </button>
                              </div>
                          </div>
                      </div>
                  </div>
              `;
          } else if (msg.type === 'step') {
            return `
              <div class="message-wrapper assistant">
                <div class="message" style="opacity:0.8;font-size:0.85em;">${msg.content}</div>
              </div>`;
          }
        })
        .join('');

      this.addMessageEventListeners();
      this.addOptionEventListeners();
      this.initializeProductCarousels();
    }

    async sendMessage({ message, functionObj }) {
      this.sendDisabled = true; // API call starts
      this.updateSendState();

      if (message) {
        this.messages.push({ role: 'user', type: 'normal', content: message });
      }
      
      // Add assistant message that will be updated with streaming content
      const assistantMessageIndex = this.messages.length;
      this.messages.push({ 
        role: 'assistant', 
        type: 'normal', 
        content: '', 
        isStreaming: true 
      });
      // Remember index for later replacement after validation
      this.currentRun.respondMessageIndex = assistantMessageIndex;
      
      this.renderMessages();

      // Scroll to the newest message
      const chatLog = this.shadowRoot.querySelector('.chat-log');
      chatLog.scrollTop = chatLog.scrollHeight;

      // Use stored threadId and assistantId from startChat response
      if (!this.threadId || !this.assistantId || !this.langGraphUrl) {
        console.error('Missing information. Make sure startChat was called successfully.');
        this.messages[assistantMessageIndex] = {
          role: 'assistant-error',
          type: 'normal',
          content: 'Session error: Missing information. Please restart the chat.',
          isStreaming: false
        };
        this.renderMessages();
        this.sendDisabled = false;
        this.updateSendState();
        return;
      }

      try {
        const streamUrl = `${this.langGraphUrl}/threads/${this.threadId}/runs/stream`;
        
        // Prepare the input for LangGraph
        const graphInput = {
          messages: [
            {
              role: 'user',
              content: message
            }
          ]
        };

        // Add function object if provided
        if (functionObj) {
          graphInput.functionObj = functionObj;
        }

        const requestBody = {
          assistant_id: this.assistantId,
          input: graphInput,
          stream_mode: ['events', 'messages', 'updates'],
          // Add session context if needed
          config: {
            configurable: {
              session_token: this.chatSession.sessionToken,
              myShopifyDomain: this.serveData.shop.myShopifyDomain,
              local_language: this.localLanguage
            }
          }
        };

        const response = await fetch(streamUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Session ${this.chatSession.sessionToken}`,
            'X-Shopify-Domain': this.serveData.shop.myShopifyDomain,
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream'
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ message: response.statusText }));
          throw new Error(`HTTP error ${response.status}: ${errorData.message || JSON.stringify(errorData)}`);
        }

        if (!response.body) {
          throw new Error("Response body is null, cannot read stream.");
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        const processStream = async () => {
          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              console.debug('[LangGraph] stream finished');
              // Mark streaming as complete
              this.messages[assistantMessageIndex].isStreaming = false;
              this.renderMessages();
              break;
            }

            const chunkText = decoder.decode(value, { stream: true });
            console.debug('[LangGraph] raw chunk', chunkText);
            buffer += chunkText;
            let delimiterIndex;
            // Split on blank line (handles \n\n or \r\n\r\n)
            const delimiterRegex = /\r?\n\r?\n/;
            while ((delimiterIndex = buffer.search(delimiterRegex)) >= 0) {
              const eventString = buffer.substring(0, delimiterIndex);
              buffer = buffer.substring(delimiterIndex).replace(delimiterRegex, '');
              console.debug('[LangGraph] event string', eventString);
              this.processSSEEvent(eventString, assistantMessageIndex);
            }
          }
        };

        await processStream();

      } catch (error) {
        console.error('There was a problem with the streaming operation:', error);
        
        // Update the message to show error
        this.messages[assistantMessageIndex] = {
          role: 'assistant-error',
          type: 'normal',
          content: `Streaming error: ${error.message}`,
          isStreaming: false
        };
        this.renderMessages();
      }

      this.setChatSession();
      this.sendDisabled = false;
      this.updateSendState();

      const inputField = this.shadowRoot.querySelector('.chat-input input');
      if (inputField) {
        inputField.focus();
      }
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    processSSEEvent(eventString, messageIndex) {
      if (!eventString.trim()) return;
      console.debug('[LangGraph] Parsing event', eventString);
      const lines = eventString.split(/\r?\n/);
      let jsonDataAccumulator = '';
      let eventType = null;

      for (const line of lines) {
        if (line.startsWith('data:')) {
          jsonDataAccumulator += line.substring(5).trim();
        } else if (line.startsWith('event:')) {
          eventType = line.substring(6).trim();
        }
      }

      console.debug('[LangGraph] eventType', eventType, 'json', jsonDataAccumulator);
      if (jsonDataAccumulator) {
        try {
          const parsedData = JSON.parse(jsonDataAccumulator);
          console.debug('[LangGraph] parsedData', parsedData);

          let shouldUpdateMessage = false;
          let newContent = '';

          // Handle messages/partial events (contains cumulative content as array)
          if (eventType === 'messages/partial') {
            // Data is an array of message objects: [{"content": "...", ...}]
            if (Array.isArray(parsedData) && parsedData.length > 0 && parsedData[0].content !== undefined) {
              newContent = parsedData[0].content;
              shouldUpdateMessage = true;
              console.log('messages/partial - New content:', newContent);
            }
          }
          // Handle events with on_chat_model_stream (individual chunks)
          else if (eventType === 'events' && parsedData.event === 'on_chat_model_stream') {
            if (parsedData.data && parsedData.data.chunk && parsedData.data.chunk.content) {
              // Append chunk content to existing message
              if (this.messages[messageIndex]) {
                newContent = (this.messages[messageIndex].content || '') + parsedData.data.chunk.content;
                shouldUpdateMessage = true;
                console.log('on_chat_model_stream - New content:', newContent);
              }
            }
          }
          // Handle events with on_custom_event that have name messages/partial
          else if (eventType === 'events' && parsedData.event === 'on_custom_event' && parsedData.name === 'messages/partial') {
            // Data format: {"data": [{"content": "...", ...}]}
            if (parsedData.data && Array.isArray(parsedData.data) && parsedData.data.length > 0 && parsedData.data[0].content !== undefined) {
              newContent = parsedData.data[0].content;
              shouldUpdateMessage = true;
              console.log('on_custom_event messages/partial - New content:', newContent);
            }
          }

          // Handle node execution information and show progress
          if (eventType === 'events' && parsedData.metadata) {
            const metadata = parsedData.metadata;
            
            // Extract node information
            if (metadata.langgraph_node) {
              const nodeInfo = {
                node: metadata.langgraph_node,
                step: metadata.langgraph_step,
                event: parsedData.event
              };
              
              this.updateNodeProgress(nodeInfo);
              console.log('Node execution:', nodeInfo);
            }
          }

          // Handle metadata events (run start)
          if (eventType === 'metadata') {
            console.log('Run started:', parsedData);
            this.showProcessingStatus('Starting...');
          }

          // Handle updates events (completion)
          if (eventType === 'updates') {
            console.log('Updates received:', parsedData);
            this.showProcessingStatus('Completed');
          }

          // Handle node lifecycle events
          if (eventType === 'events' && parsedData.event && parsedData.metadata && parsedData.metadata.langgraph_node) {
            const nodeName = parsedData.metadata.langgraph_node;
            const nodeEvent = parsedData.event;
            if (nodeEvent === 'on_chain_start') {
              // Create a step message if not already present
              if (!this.currentRun.steps[nodeName]) {
                const stepMsgIndex = this.messages.length;
                this.currentRun.steps[nodeName] = { status: 'running', msgIndex: stepMsgIndex };
                this.messages.push({
                  role: 'assistant-step',
                  type: 'step',
                  content: `üîÑ ${this.getNodeStatusText({node:nodeName})}`,
                  isStreaming: false,
                });
                this.renderMessages();
              }
            } else if (nodeEvent === 'on_chain_end') {
              // Mark step done
              const stepInfo = this.currentRun.steps[nodeName];
              if (stepInfo) {
                this.messages[stepInfo.msgIndex].content = `‚úÖ ${this.getNodeStatusText({node:nodeName})}`;
                this.renderMessages();
              }
              // If validateClaims ended, use validatedResponse
              if (nodeName === 'validateClaims') {
                const validated = parsedData.data && parsedData.data.output && parsedData.data.output.validatedResponse;
                if (validated && this.currentRun.respondMessageIndex !== null) {
                  const idx = this.currentRun.respondMessageIndex;
                  this.messages[idx].content = validated;
                  this.messages[idx].isStreaming = false;
                  this.renderMessages();
                }
              }
            }
          }

          // Update the message if we have new content
          if (shouldUpdateMessage && this.messages[messageIndex]) {
            this.messages[messageIndex].content = newContent;
            this.messages[messageIndex].isStreaming = true;
            this.renderMessages();
            
            // Auto-scroll to keep up with streaming content
            const chatLog = this.shadowRoot.querySelector('.chat-log');
            if (chatLog) {
              chatLog.scrollTop = chatLog.scrollHeight;
            }
          }

        } catch (error) {
          console.warn('Failed to parse SSE data:', error, jsonDataAccumulator);
        }
      }
    }

    updateNodeProgress(nodeInfo) {
      // Find or create a progress indicator in the streaming message
      const messageIndex = this.messages.length - 1;
      if (this.messages[messageIndex] && this.messages[messageIndex].isStreaming) {
        // Add node progress to the message
        this.messages[messageIndex].nodeProgress = nodeInfo;
        
        // Show a temporary status indicator
        const statusText = this.getNodeStatusText(nodeInfo);
        this.showProcessingStatus(statusText);
      }
    }

    getNodeStatusText(nodeInfo) {
      const nodeDisplayNames = {
        'respond': 'üí¨ Generating response',
        'validateClaims': '‚úÖ Validating content',
        'retrieveProducts': 'üîç Finding products',
        'default': `‚öôÔ∏è ${nodeInfo.node}`
      };
      
      return nodeDisplayNames[nodeInfo.node] || nodeDisplayNames.default;
    }

    showProcessingStatus(status) {
      // Create or update a temporary status indicator
      let statusElement = this.shadowRoot.querySelector('.processing-status');
      
      if (!statusElement) {
        statusElement = document.createElement('div');
        statusElement.className = 'processing-status';
        const chatLog = this.shadowRoot.querySelector('.chat-log');
        if (chatLog) {
          chatLog.appendChild(statusElement);
        }
      }
      
      statusElement.textContent = status;
      statusElement.style.display = 'block';
      
      // Auto-hide after 2 seconds
      setTimeout(() => {
        if (statusElement) {
          statusElement.style.display = 'none';
        }
      }, 2000);
    }

    handleSpecialResponse(responseData, messageIndex) {
      // Handle special response types like orderTracking, productRecommendation, etc.
      if (responseData.type === 'orderTracking') {
        this.messages[messageIndex] = {
          role: 'assistant',
          type: 'orderTracking',
          order: responseData.order,
          options: responseData.options,
          isStreaming: false
        };
        this.renderMessages();
      } else if (responseData.type === 'productRecommendation') {
        this.messages[messageIndex] = {
          role: 'assistant',
          type: 'productRecommendation',
          products: responseData.products,
          isStreaming: false
        };
        this.renderMessages();
      } else if (responseData.type === 'normal') {
        this.messages[messageIndex] = {
          role: 'assistant',
          type: 'normal',
          content: responseData.reply || responseData.content,
          options: responseData.options,
          isStreaming: false
        };
        this.renderMessages();
      }
    }

    loadScripts() {
      if (!this.scriptsLoaded) {
        const scriptPromises = [];

        const markedScript = document.createElement('script');
        markedScript.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        scriptPromises.push(
          new Promise((resolve, reject) => {
            markedScript.onload = resolve;
            markedScript.onerror = reject;
            this.shadowRoot.appendChild(markedScript);
          })
        );

        const purifyScript = document.createElement('script');
        purifyScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.8/purify.min.js';
        scriptPromises.push(
          new Promise((resolve, reject) => {
            purifyScript.onload = resolve;
            purifyScript.onerror = reject;
            this.shadowRoot.appendChild(purifyScript);
          })
        );

        const splideScript = document.createElement('script');
        splideScript.src = 'https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/js/splide.min.js';
        scriptPromises.push(
          new Promise((resolve, reject) => {
            splideScript.onload = resolve;
            splideScript.onerror = reject;
            this.shadowRoot.appendChild(splideScript);
          })
        );

        const splideCSS = document.createElement('link');
        splideCSS.rel = 'stylesheet';
        splideCSS.href = 'https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/css/splide.min.css';
        this.shadowRoot.appendChild(splideCSS);

        Promise.all(scriptPromises)
          .then(() => {
            this.scriptsLoaded = true;
            this.renderBase();
          })
          .catch((error) => {
            console.error('Error loading scripts:', error);
          });
      }
    }

    initializeProductCarousels() {
      const productCarousels = this.shadowRoot.querySelectorAll('.carousel');
      productCarousels.forEach((carouselElement, index) => {
        const splide = new Splide(carouselElement, {
          type: 'slide',
          perPage: 1,
          gap: '10px',
          padding: { left: '0', right: '40px' },
          arrows: true,
          pagination: false,
          keyboard: true,
          drag: true,
          autoplay: true,
          interval: 5000,
          pauseOnHover: true,
          pauseOnFocus: true,
          direction: 'ltr',
        });

        const progressBar = splide.root.querySelector('.carousel-progress-bar');

        splide.on('mounted move', function () {
          let end = splide.Components.Controller.getEnd() + 1;
          let rate = Math.min((splide.index + 1) / end, 1);
          progressBar.style.width = String(100 * rate) + '%';
        });

        splide.mount();
      });
    }

    handleToggleChatClick(event) {
      event.stopPropagation();
      this.isOpen = !this.isOpen;
      this.toggleBodyScroll(this.isOpen && this.isMobile);
      this.renderBase();
    }

    toggleBodyScroll(disable) {
      if (disable) {
        document.body.style.overflow = 'hidden';
        document.body.style.height = '100%';
      } else {
        document.body.style.overflow = '';
        document.body.style.height = '';
      }
    }

    handleRestartChatButtonClick() {
      this.chatSession.active = false;
      this.chatSession.expiresAt = null;
      this.chatSession.sessionToken = null;
      this.chatSession.transcript = null;
      
      // Clear assistantId and threadId
      this.assistantId = null;
      this.threadId = null;
      this.langGraphUrl = null;
      
      localStorage.removeItem('soof-chat-session');

      this.messages = [];
      this.messages.push({
        role: 'assistant',
        type: 'normal',
        content: this.startChatMessage,
      });

      this.messages.push({
        role: 'assistant',
        type: 'email-input',
        email: this.chatSession.userEmail || null,
      });

      this.renderBase();
    }

    handleFaqButtonClick() {}

    handleSendButtonClick() {
      const inputField = this.shadowRoot.querySelector('.chat-input input');
      if (inputField.value.trim() && !this.sendDisabled) {
        this.sendMessage({ message: inputField.value.trim() });
        this.clearAndFocusInput(inputField);
      }
    }

    handleInputKeydown(e) {
      const inputField = e.target;

      if (e.key === 'Enter' && inputField.value.trim()) {
        if (inputField.type === 'email') {
          this.startChat({
            email: inputField.value.trim()
          });
          this.clearAndFocusInput(inputField);
        } else if (inputField.type === 'text' && !this.sendDisabled) {
          this.sendMessage({ message: inputField.value.trim() });
          this.clearAndFocusInput(inputField);
        }
      }
    }

    handleEmailSendButtonClick() {
      const emailInputField = this.shadowRoot.querySelector('.email-input input[type="email"]');
      if (emailInputField.value.trim()) {
        this.startChat({
          email: emailInputField.value.trim()
        });
        this.clearAndFocusInput(emailInputField);
      }
    }

    clearAndFocusInput(inputField) {
      inputField.value = '';
      inputField.focus();
    }

    updateSendState() {
      const sendButton = this.shadowRoot.getElementById('send-button');

      if (this.sendDisabled || !this.chatSession.active) {
        sendButton.setAttribute('disabled', 'disabled');
      } else {
        sendButton.removeAttribute('disabled');
      }
    }

    addBaseEventListeners() {
      this.shadowRoot
        .querySelector('.toggle-chat-button')
        .addEventListener('click', this.handleToggleChatClick.bind(this));

      if (this.isOpen) {
        this.shadowRoot
          .getElementById('restart-chat-button')
          .addEventListener('click', this.handleRestartChatButtonClick.bind(this));
        // TODO: Add FAQ button
        // this.shadowRoot.getElementById('faq-button').addEventListener('click', this.handleFaqButtonClick.bind(this));
        this.shadowRoot.getElementById('send-button').addEventListener('click', this.handleSendButtonClick.bind(this));
        this.shadowRoot
          .getElementById('chat-input-field')
          .addEventListener('keydown', this.handleInputKeydown.bind(this));
      }
    }

    addMessageEventListeners() {
      if (!this.chatSession.active) {
        this.shadowRoot
          .querySelector('.email-input input')
          .addEventListener('keydown', this.handleInputKeydown.bind(this));
        this.shadowRoot
          .getElementById('email-send-button')
          .addEventListener('click', this.handleEmailSendButtonClick.bind(this));
      }
    }

    addOptionEventListeners() {
      this.messages.forEach((msg, msgIndex) => {
        if (msg.options) {
          msg.options.forEach((option, optionIndex) => {
            const button = this.shadowRoot.querySelector(`#option-button-${msgIndex}-${optionIndex}`);
            if (button) {
              button.addEventListener('click', () => {
                this.messages[msgIndex].options = this.messages[msgIndex].options.filter(
                  (_, index) => index !== optionIndex
                );

                if (option.function) {
                  const params = option.function.params || {};
                  this[option.function.name](params);
                } else if (option.value) {
                  this.sendMessage({ message: option.value });
                } else {
                  console.error(`Option button ${option.label} has no function or value.`);
                }
              });
            }
          });
        }
      });
    }

    // Option Functions
    async sendOrderTracking(params) {
      const functionObj = {
        name: 'sendOrderTracking',
        params: {
          orderId: params.orderId,
        },
      };
      this.sendMessage({ functionName: 'sendOrderTracking', functionObj });
    }
  }

  // Define the new element
  if (!customElements.get('soof-chat')) {
    customElements.define('soof-chat', ChatBot);
  }
</script>

{% schema %}
  {
    "name": "Soof Chat",
    "target": "body",
    "settings": []
  }
{% endschema %}